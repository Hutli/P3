As part of the analysis of the application domain an analysis of the functions are needed. It is done in order to get an understanding of what the system should do. A function is something that makes the model usable by the user and supports their use cases. There are three different kinds of functions:

\begin{description}
    \item[Update] functions are functions that are triggered by an event in the problem or application domain that then needs to update the state of the model. Update functions are used to keep the model up to date with reality.

    \item[Signalling] functions are triggered by changes in the model. They notify the actors or do a direct action in the problem domain.

    \item[Read] functions are functions that makes the model readable by
the outside. It is used by an actor when updates from the model is needed in the system.

    \item[Compute] functions are similar to read functions but instead of just reading the model they do some extra computation. They might also read different places in the model and combining them with some computation.
\end{description}

In \cref{table:functionlist} is a table of functions from the system. The functions were made based on Use cases described in \cref{usecase} and the systems definition in \cref{systemDefinition}. The table also includes the complexity of the functions. This is a subjective assessment made in collaboration with the users of the system. It tells how difficult a function is to develop. Most functions can be specified with just a name but some of the more complex functions needs to have a detailed specification.

\begin{table}[hbtp]
\centering
\begin{tabular}{lcr}
\toprule
\multicolumn{3}{c}{\textbf{Social music playing}} \\
\midrule
Restrict tracks                & Medium  & Compute \\
Create restriction             & Simple  & Update  \\
Read restriction               & Simple  & Read    \\
Update restriction             & Simple  & Update  \\
Delete restriction             & Simple  & Update  \\
Get current playlist           & Simple  & Read    \\
Change track votes             & Simple  & Update  \\
Play track on speakers         & Medium  & Signal  \\
Change playing state           & Medium  & Update  \\
Track vote                     & Medium  & Update  \\
Get next track                 & Complex & Compute \\
Search tracks                  & Complex & Read    \\
\bottomrule
\end{tabular}
\caption{Function list}
\label{table:functionlist}
\end{table}

Pseudocode approximation of the two functions marked as complex in \cref{table:functionlist} can be seen in \cref{alg:GetNextTrack} and \cref{alg:Search}.

\begin{algorithm}[htbp]
\caption{Algorithm for finding the next track to be played.}\label{alg:GetNextTrack}
\begin{algorithmic}[1]
	\Function{GetNextTrack}{$playlist$,$history$}
		\State{$nextTrack$ = $null$}
		\If{$playlist$ $is$ $empty$}
			\State{$nextTrack$ = $FindRelated$($history$)}
			\State{\Return{$nextTrack$}}
		\EndIf{}
		\State{$nextTrack$ = $playlist[0]$}
		\ForAll{$track$ \textbf{in} $playlist$}
			\If{$track.Votes$ > $nextTrack.Votes$}
				\State{$nextTrack$ = $track$}
			\Else{} 
				\If{$track.Votes$ == $nextTrack.Votes$}
					\If{$track.Votes[0].Time$ > $nextTrack.Votes[0].Time$}
						\State{$nextTrack$ = $track$}
					\EndIf{}
				\EndIf{}
			\EndIf{}
		\EndFor{}
		\State{\Return{$nextTrack$}}
	\EndFunction{}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[htbp]
\caption{Algorithm for finding tracks}\label{alg:Search}
\begin{algorithmic}[1]
	\Function{Search}{$query$,$restrictions$}
		\State{$results$ = $GetResults$($query$)}
		\ForAll{$track$ \textbf{in} $results$}
			\State{$Restrict$($track$,$restrictions$)}
		\EndFor{}
		\Return{$results$}
	\EndFunction{}\\
	\Function{Restrict}{$track$,$restrictions$}
		\ForAll{$restriction$ \textbf{in} $restrictions$}
			\If{$restriction$($track$)}
				\State{$track.IsAllowed$ = $true$}
			\Else{}
				\State{$track.IsAllowed$ = $false$}
			\EndIf{}
		\EndFor{}
		\State{\Return{$track$}}
	\EndFunction{}
\end{algorithmic}
\end{algorithm}
