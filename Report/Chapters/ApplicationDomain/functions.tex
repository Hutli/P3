As part of the analysis of the application domain, an analysis of the functions are needed. It is done in order to get an understanding of what the system should do. A function is something that makes the model usable by the user and supports their use cases. There are three different kinds of functions:

\begin{description}
    \item[Update] functions are triggered by an event in the problem or application domain that then needs to update the state of the model. Update functions are used to keep the model up to date with reality.

    \item[Signalling] functions are triggered by changes in the model. They notify the actors or do a direct action in the problem domain.

    \item[Read] functions make the model readable by the outside. It is used by an actor when updates from the model is needed in the system.

    \item[Compute] functions are similar to read functions, but instead of only reading the model they do some extra computation. They might also read different places in the model and combining them with some computation.
\end{description}

In \cref{table:functionlist} is a table of functions from the system. The functions were made based on the use cases described in \cref{usecase} and the system definition in \cref{systemDefinition}. The table also includes the complexity of the functions. The complexity tells how difficult a function is to develop. Most functions can be specified with just a name but some of the more complex functions needs to have a detailed specification.

\begin{table}[hbtp]
\centering
\begin{tabular}{lcr}
\toprule
\textbf{Name}									 & \textbf{Complexity}	& \textbf{Type} \\
\midrule
Change track votes             & Simple								& Update  \\
Create restriction             & Simple								& Update  \\
Delete restriction             & Simple								& Update  \\
Update restriction             & Simple								& Update  \\
Get current playlist           & Simple								& Read    \\
Read restriction               & Simple								& Read    \\
Change playing state           & Medium								& Update  \\
Track vote                     & Medium								& Update  \\
Play track on speakers         & Medium								& Signal  \\
Restrict tracks                & Medium								& Compute \\
Search tracks                  & Complex							& Read    \\
Get next track                 & Complex							& Compute \\
\bottomrule
\end{tabular}
\caption{Function table.}
\label{table:functionlist}
\end{table}

Pseudocode approximation of the two functions marked as complex in \cref{table:functionlist} can be seen in \cref{alg:GetNextTrack} and \cref{alg:Search}.

\begin{algorithm}[htbp]
\caption{Algorithm for finding the next track to be played.}\label{alg:GetNextTrack}
\begin{algorithmic}[1]
	\Function{GetNextTrack}{$playlist$,$history$}
		\State{$nextTrack$ = $null$}
		\If{$playlist$ $is$ $empty$}
			\State{$nextTrack$ = $FindRelated$($history$)}
			\State{\Return{$nextTrack$}}
		\EndIf{}
		\State{$nextTrack$ = $playlist[0]$}
		\ForAll{$track$ \textbf{in} $playlist$}
			\If{$track.Votes$ > $nextTrack.Votes$}
				\State{$nextTrack$ = $track$}
			\Else{} 
				\If{$track.Votes$ == $nextTrack.Votes$}
					\If{$track.Votes[0].Time$ > $nextTrack.Votes[0].Time$}
						\State{$nextTrack$ = $track$}
					\EndIf{}
				\EndIf{}
			\EndIf{}
		\EndFor{}
		\State{\Return{$nextTrack$}}
	\EndFunction{}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[htbp]
\caption{Algorithm for finding tracks}\label{alg:Search}
\begin{algorithmic}[1]
	\Function{Search}{$query$,$restrictions$}
		\State{$results$ = $GetResults$($query$)}
		\ForAll{$track$ \textbf{in} $results$}
			\State{$Restrict$($track$,$restrictions$)}
		\EndFor{}
		\Return{$results$}
	\EndFunction{}\\
	\Function{Restrict}{$track$,$restrictions$}
	\State{$track.IsAllowed = true$}
		\ForAll{$restriction$ \textbf{in} $restrictions$}
			\If{!$restriction$($track$)}
				\State{$track.IsAllowed$ = $false$}
				\State{\Return{$track$}}
			\EndIf{}
		\EndFor{}
		\State{\Return{$track$}}
	\EndFunction{}
\end{algorithmic}
\end{algorithm}
