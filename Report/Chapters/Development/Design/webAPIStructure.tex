The structure of the classes in the project, have been dictated by how the json code from a search on the Spotify Web API is structured. When using the Web API to search on Spotify, three different items can be found Track, Album and Artist. These three items are all identified by a unique ID from Spotify which is what we also uses as the id for the item in our allocation.
A small problem occurs in that the user, although always eventually looking for a track, does not always find the track directly via the title, but often via the artist by whom it was created or album on which the track is placed. It was therefore chosen that for each search it must be specified, what item that is being searched for. To minimize the requirements for the user, it was decided that the user, should not specify what item he or she is searching for himself, but rather he or she should write the search string, and get a complete list of the results for all items represented. Therefore it has been implemented, that it is possible, when creating a Search object, to specify from an enum which of the three items or all three are being searched for. When choosing all three, which is what we do for the users, three individual searches are created and the results are represented in a complete structure shown in \cref{fig:WebAPIUML}.

\begin{figure}
  \centering
  \includegraphics[width=0.5\linewidth]{Images/WebAPIUML.jpg}
  \caption{A class diagram showing the class structure of the results generated from a search}
  \label{fig:WebAPIUML}
\end{figure}

It was decided to have a minimal data download approach when designing the web API. This was done on the bases of the assumption that this API would most likely be the system used for searching for new tracks on the mobile front-end application and since mobile phones still have limited data access it is preferable for the user to use as little data as possible. This approach results in that only these three searches are done initially and other requests are not done until other information about the item is needed (explained in a bit). Furthermore this also resulted in all information is stored in the objects and is saved until the search object is removed and the user hopefully has found his or her track.

As mentioned earlier one search usually searches for all three different items, track, album and artist, and present these to the user. Not all information about the artists and albums can be gathered from the json code received from these three initial searches. Albums does not have information about it tracks nor its artists initially and an artist does not have information about its albums. The minimal data approach was therefore combined with another idea, data just in time. This was done since the user normally only wants information from one type of item and not the two remaining and it would therefore be undesirable for the user to wait for all information for every item to be downloaded. This also fits very well with the minimal data approach since this, if the user does not look though all items in the search, minimize the amount of data requested. The information not received from the initial searches are therefore only requested from Spotify when the get method for the properties on items are called, but to keep faithful to the minimal data approach these information, when first received, are cached to the application and saved in the object structure.