\section{Restrictions}
\label{sec:restrictions}

As described in \cref{FACTOR} and confirmed by with our industry partner in \cref{sec:fabrikken}, the system should have the ability to control what guests can vote for. The concept described for solving this problem, is by putting restrictions on what tracks, can be added to the playlist. This section will present how this concept is designed via white- and black-listing.

\paragraph{Whitelisting} is a concept of being able to choose, what entities is accepted as a valid input. Strictly if $A$ is the set of accepted inputs, $B$ is the whitelist set and $i$ is the input then $i \in A$ \textbf{if and only if} $i \in B$. If there are multiple whitelists, the input is valid if it is contained in any of them.
To get a better understanding of how this works mathematically, we can convert a whitelist to a logical expression evaluating to \textbf{true} if the item is on the whitelist or \textbf{false} if not. With $n$ whitelists these logical expressions can combined into logical expression evaluating to \textbf{true} if the track is allowed and \textbf{false} if not, this can be seen in \cref{eq:whitelist}.

\begin{equation}
\label{eq:whitelist}
	W_1 \vee W_2 \vee W_3 \vee ... \vee W_n
\end{equation}

\paragraph{Blacklisting} is the reverse of whitelisting. The concept is that the blacklist excludes specific entities from being a valid input. Entities in the blacklist set is excluded from the set of accepted inputs. Strictly $A$ is the set of accepted inputs, $B$ is the blacklist set and $i$ is the input set then $i \in A$ \textbf{if and only if} $i \notin B$.
We can in the same way as whitelists convert a blacklist to a logical expression returning \textbf{true} if the item is on the blacklist or \textbf{false} if not, and again with $n$ blacklists create a combined logical expression that would evaluate \textbf{true} if a track is allowed and \textbf{false} if not, as seen in \cref{eq:blacklist}.

\begin{equation}
\label{eq:blacklist}
	\neg(B_1 \vee B_2 \vee B_3 \vee ... \vee B_n)
\end{equation}

For an entity to be accepted it must be evaluated as \textbf{true} in both of the combined logical expressions in \cref{eq:blacklist} and \cref{eq:whitelist}. These expressions can therefore be combined into one expression as seen in \cref{eq:blacklist&whitelist}.

\begin{equation}
\label{eq:blacklist&whitelist}
		(W_1 \vee W_2 \vee ... \vee W_n) \wedge \neg(B_1 \vee B_2 \vee ... \vee B_n)
\end{equation}

One restriction is a collection of rules on any of the meta data a track contains. This means that if you do not want to hear \enquote{Still Alive} by \enquote{Lisa Miskovsky} this is one blacklist restriction. People would still be able to hear other songs titled \enquote{Still Alive} or other music from \enquote{Lisa Miskovsky}. For an entity to evaluate true, thus being on the blacklist or whitelists, it must be true for all criterias of the list. For \emph{n} whitelists and \emph{m} blacklists with a variable number of criterias the complete and final expression would look as seen in \cref{eq:restrictions}.

\begin{eqnarray}
	\label{eq:restrictions}
	((W_{1.1} \wedge ... \wedge W_{1.a}) \vee (W_{2.1} \wedge ... \wedge W_{2.b}) \vee ... \vee (W_{n.1} \wedge ... \wedge W_{n.c})) \wedge \nonumber \\ \neg((B_{1.1} \wedge ... \wedge B_{1.d}) \vee (B_{2.1} \wedge ... \wedge B_{2.e}) \vee ... \vee (B_{m.1} \wedge ... \wedge B_{m.f}))
\end{eqnarray}

With these concepts it is possible to restrict the music catalogue to a subset of allowed tracks, satisfying the requirement of being able to control what music is being played.


Restrictions can also improve the music flow (described in \cref{sub:MusicFlow}) if the restrictions limits allowed tracks to certain genre or mood, although this should be just be supplement to another concept, analysing the tracks on the playlist.

Furthermore the owner of Fabrikken (see \cref{sec:fabrikken}) wants to be able to have timed intervals of restrictions, so that the restrictions acts accordingly to the progression in intensity and mood of the bar environment. This is quite trivially implemented with a selective control structure, checking if the restriction is relevant at that time of day.


\begin{algorithm}[htbp] \caption{Algorithm for filtering tracks in a search}\label{alg:Search}
\begin{algorithmic}[1]
	\Function{Search}{$query$, $restrictions$}
		\State{$results$ := $GetResults$($query$)}
		\ForAll{$track$ \textbf{in} $results$}
			\State{$track.IsAllowed$ := $Restrict$($track$,$restrictions$)}
		\EndFor{}
		\Return{$results$}
	\EndFunction{}\\
	\Function{Restrict}{$track$, $restrictions$}
		\State{$WhitelistExists$ := $false$}
		\State{$IsOnWhitelist$ := $false$}
		\State{$IsOnBlacklist$ := $false$}
		\ForAll{$restriction$ \textbf{in} $restrictions$}
			\If{$restriction.Type$ = $whitelist$ $\wedge$ $\neg IsOnWhitelist$}
				\State{$WhitelistExists$ := $true$}
				\State{$IsOnWhitelist$ := $restriction$($track$)}
			\EndIf{}
			\If{$restriction.Type$ = $blacklist$ $\wedge$ $\neg IsOnBlacklist$}
				\State{$IsOnBlacklist$ := $restriction$($track$)}
			\EndIf{}
		\EndFor{}
		\State{\Return{($WhitelistExists$ $\to$ $IsOnWhitelist$) $\wedge$ $\neg IsOnBlacklist$}}
	\EndFunction{}
\end{algorithmic}
\end{algorithm}
