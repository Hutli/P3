\section{Restrictions}
\label{sec:restrictions}

As described in \cref{FACTOR} and confirmed by with our industry partner in \cref{sec:fabrikken}, the system should have the ability to control what guests can vote for. The concept described for solving this problem, is by putting restrictions on what tracks, can be added to the playlist. This section will present how this concept is designed via white- and black-listing.

\paragraph{Whitelisting} is a concept of being able to choose, what entities is accepted as a valid input. Strictly if $A$ is the set of accepted inputs, $B$ is the whitelist set and $i$ is the input then $i \in A$ \textbf{if and only if} $i \in B$. If there are multiple whitelists, the input is valid if it is contained in any of them.
To get a better understanding of how this works mathematically, we can convert a whitelist to a logical expression evaluating to \textbf{true} if the item is on the whitelist or \textbf{false} if not. With $n$ whitelists these logical expressions can combined into logical expression evaluating to \textbf{true} if the track is allowed and \textbf{false} if not, this can be seen in \cref{eq:whitelist}. When $n$ = $0$, there are no whitelists tracks have to be on and all tracks are therefore accepted, with respect to the whitelist set. We therefore define expression to return \textbf{true} if $n$ = $0$.

\begin{equation}
\label{eq:whitelist}
	W_1 \vee W_2 \vee W_3 \vee \dots \vee W_n
\end{equation}

\paragraph{Blacklisting} is the reverse of whitelisting. The concept is that the blacklist excludes specific entities from being a valid input. Entities in the blacklist set is excluded from the set of accepted inputs. Strictly $A$ is the set of accepted inputs, $B$ is the blacklist set and $i$ is the input set then $i \in A$ \textbf{if and only if} $i \notin B$.
We can in the same way as whitelists convert a blacklist to a logical expression returning \textbf{true} if the item is on the blacklist or \textbf{false} if not, and again with $n$ blacklists create a combined logical expression that would evaluate \textbf{true} if a track is allowed and \textbf{false} if not, as seen in \cref{eq:blacklist}. When $n$ = $0$, there are no blacklists. When there are no blacklists no tracks are filtered and all tracks return true with respect to the blacklist set. We therefore define the whole, including the negation, expression to return \textbf{true}.

\begin{equation}
\label{eq:blacklist}
	\neg(B_1 \vee B_2 \vee B_3 \vee \dots \vee B_n)
\end{equation}

For an entity to be accepted it must be evaluated as \textbf{true} in both of the combined logical expressions in \cref{eq:blacklist} and \cref{eq:whitelist}. These expressions can therefore be combined into one expression as seen in \cref{eq:blacklist&whitelist}. The logic of this combined expression can be stated as follows; If and only if a track is contained in \textbf{any} of the whitelists, or there are no whitelists, \textbf{and} is \textbf{not} contained in \textbf{any} of the blacklists, or there are no blacklists, the tracks is allowed.

\begin{equation}
\label{eq:blacklist&whitelist}
		(W_1 \vee W_2 \vee \dots \vee W_n) \wedge \neg(B_1 \vee B_2 \vee \dots \vee B_n)
\end{equation}

One restriction is a collection of rules on any of the meta data a track contains. This means that if you do not want to hear \enquote{Still Alive} by \enquote{Lisa Miskovsky} this is one blacklist restriction. People would still be able to hear other songs titled \enquote{Still Alive} or other music from \enquote{Lisa Miskovsky}. For an entity to evaluate true, thus being on the blacklist or whitelists, it must be true for all criterias of the list. For \emph{n} whitelists and \emph{m} blacklists with a variable number of criterias the complete and final expression would look as seen in \cref{eq:restrictions}.

\begin{eqnarray}
	\label{eq:restrictions}
	((W_{1.1} \wedge \dots \wedge W_{1.a}) \vee (W_{2.1} \wedge \dots \wedge W_{2.b}) \vee \dots \vee (W_{n.1} \wedge \dots \wedge W_{n.c})) \wedge \nonumber \\ \neg((B_{1.1} \wedge \dots \wedge B_{1.d}) \vee (B_{2.1} \wedge \dots \wedge B_{2.e}) \vee \dots \vee (B_{m.1} \wedge \dots \wedge B_{m.f}))
\end{eqnarray}

With these concepts it is possible to restrict the music catalogue to a subset of allowed tracks, satisfying the requirement of being able to control what music is being played.

In \cref{alg:Search} the pseudo code that implements the functionality, described earlier in this section. This algorithm works with the same logic as described in \cref{eq:blacklist&whitelist}. First a list of tracks are found from a search query. For each of these tracks a property telling whether the track is allowed or not is set via the \enquote{Restrict} function. This function evaluates each restriction, the predicates that return whether an item is on the list or not. For each of these restrictions one disjunction is formed from whitelists and one disjunction from the blacklists. If any whitelists are found an extra bool is also set. In the last line the it then returns a conjunction from these two disjunctions but with the blacklist disjunction negated according to \cref{eq:blacklist&whitelist}. The boolean for checking whether a whitelist exists is used since the whitelist disjunction returns false if there are no whitelists, and this conflicts with the definition of whitelists when $n$ = $0$. Writing that \enquote{WhitelistExists} implies \enquote{IsOnWhitelist} results in the expression always returning true when there are no whitelists. This is not necessary for blacklists since the negation results in when there are no blacklists the boolean cannot be set to true, will always be false and the expression will be true.

\begin{algorithm}[htbp] \caption{Algorithm for filtering tracks in a search}\label{alg:Search}
\begin{algorithmic}[1]
	\Function{Search}{$query$, $restrictions$}
		\State{$results$ := $GetResults$($query$)}
		\ForAll{$track$ \textbf{in} $results$}
			\State{$track.IsAllowed$ := $Restrict$($track$,$restrictions$)}
		\EndFor{}
		\Return{$results$}
	\EndFunction{}\\
	\Function{Restrict}{$track$, $restrictions$}
		\State{$WhitelistExists$ := $false$}
		\State{$IsOnWhitelist$ := $false$}
		\State{$IsOnBlacklist$ := $false$}
		\ForAll{$restriction$ \textbf{in} $restrictions$}
			\If{$restriction.Type$ = $whitelist$}
				\State{$WhitelistExists$ := $true$}
				\State{$IsOnWhitelist$ := $IsOnWhitelist$ $\vee$ $restriction$($track$)}
			\ElsIf{$restriction.Type$ = $blacklist$}
				\State{$IsOnBlacklist$ := $IsOnBlacklist$ $\vee$ $restriction$($track$)}
			\EndIf{}
		\EndFor{}
		\State{\Return{($WhitelistExists$ $\to$ $IsOnWhitelist$) $\wedge$ $\neg IsOnBlacklist$}}
	\EndFunction{}
\end{algorithmic}
\end{algorithm}

Besides enableing administrators to restrict the search area, restrictions can also improve the music flow (described in \cref{sub:MusicFlow}). If the restrictions limits allowed tracks to certain genre or mood, within a certain timespan users will only be able to vote for songs that fit the current music at the time. This was also expressed by the owner of Fabrikken (see \cref{sec:fabrikken}). He expressed that he wants to be able to have timed intervals of restrictions, so that the restrictions acts accordingly to the progression in intensity and mood of the bar environment. This is quite trivially implemented with a selective control structure, checking if the restriction is relevant at that time of day. This solution to improved music flow should only be supplement to another concept, the system being able to analyse the tracks on the playlist and automatically choose the next track. An algorithm for this is presented in \cref{sec:algorithm}.