\subsection{Backend server}

	A backend server is required to receive communicated requests from the client, this section holds the technical decisions, and complementary argumentation regarding: 
	\begin{itemize}
		\item How to communicate between client and server
		\item How to output audio in the system
		\item What side of the system should be responsible for searching
	\end{itemize}

	\paragraph{Searching}
	Two immediate possibilities were apparent: 
	\begin{itemize}
		\item The client sends a search query on the backend, the backend applies the filter and return the results to the client 
		\item The backend sends the filter to the client and the client searches and applies the filter
	\end{itemize}
	Letting the clients handle the search meant better scalablity, because the backend does not have to handle the individual queries of each client, but only distribute a filter and receive vote enquiries. The filter would not have to be distributed all the time, only once when the client checks in at the bar and when the filter is updated, this way the search would be quicker by minimizing the systems involved in the system, given that the client's CPU can filter results faster than receiving result from an external source. 
	
	In favour of letting the backend handle the search would be that less computations would have to be done on the client, minimizing battery usage and only relevant search results(already filtered on the backend) would be downloaded, which could potentially save network bandwidth for the user. 
	
	The approach with letting the client search and filter the results were chosen, this seemed most sensible due to the backend already handling the audio data stream from Spotify and keeping track of votes, so to reduce the system requirements in terms of network and CPU power.

	\paragraph{Communication with client}
	For communicating the filter and votes between the server and client, Nancy \cite{nancy}, a lightweight framework for build http services on .Net, available from NuGet, was chosen. Nancy is easy to set up as selfhosting, and can asynchronised from the rest of the backend, only reporting back to the main thread when a request is executed. So the client simply has to send a http request on a designated port, to interact with the server... \chnote{Skal udvides vi har bare ikke rigtig undersøgt muligheder og begrænsninger} 

	\paragraph{Audio output}
	When receiving the data stream from Spotify, some way of outputting the actual audio is needed, the data stream is of type Pulse Code Modulation (PCM), in searching for a way to playback PCM data the following candidates were found:

\begin{itemize}
	\item Naudio \cite{naudio} - A well established open source library, still being updated, available through NuGet
	\item Alvas.Audio \cite{alvas} - Proprietary C\# audio library for .Net. Requires a license.
	\item BASS.NET \cite{bass} - A 3rd party .Net wrapper for the BASS audio library, still being updated. Requires a license.
	\item SoundPlayer - Intergrated in the .Net framework, but only supports .wav PCM data stream.
\end{itemize}

	The features of these candidates is pretty distributed, apart from the SoundPlayer class of the .Net framework, Should the system be required to handle other compressed data streams, SoundPlayer would struggle due to having to convert the data before delivering it. Of the remaining candidates the project group sought to minimize cost of the system, and keep it as open source as possible, thereby leaving out the proprietary candidates. Leaving Naudio as the only candidate and most sensible in terms of extensibility.