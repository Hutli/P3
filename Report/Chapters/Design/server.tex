\subsection{Backend server}

	A backend server is required to recieve communicated request from the client, this section holds the technical decisions, and complementary argumentation, regarding: how we will communicate between client and server, how we output audio in the system, what side of the system should be responsible for searching.

	\paragraph{Searching}
	To imediate possiblities were apparent: making a search query on the backend, apply the filter and return results to the client or send the filter to the client and the client search and apply the filter on the client.
	Letting the clients handle the search meant better scalablity, because the backend does have to handle the invidual queries of each client, only distribute a common filter and recieve vote enqueries. The filter would not have to be distrubuted all the time, once when the client checks in at the bar and when the filter is updated, this way the search would be quicker by minimizing the systems involved in the system, given that the clients cpu can filter results faster recieving result from an external source. In favor of letting the backend handling the search would be that less computations would have to be done on the client, minimizing battery usage and only relevant search results(already filtered on the backend) would be downloaded, which could potentialy save network bandwidth for the user. The approach with letting the client search and filter the results were chosen, this seemed most sensible due to the backend already handling the audio data stream from spotify and keep track of votes, so to reduce the system requirements in terms of network and cpu.

	\paragraph{Communication with client}
	For communicating the filter and votes the server and client between, Nancy \cite{nancy} were chosen, a lightweight framework for build http services on .Net, availible from NuGet. Nancy is easy to setup as selfhosting, and can asynchronised from the rest of the backend, reporting back to the main thread when a request is executed. So the client simply has to send a request to a http request on a desegnated port, to interact with the server... \chnote{Skal udvides vi har bare ikke rigtig undersøgt muligheder og begrænsninger} 

	\paragraph{Audio output}
	When recieving data stream from spotify, some way of outputting the actual audio is need, the data stream is of type Pulse Audio Modulation (PCM), searching for a way to playback pcm data following candidates were:

\begin{itemize}
	\item Naudio \cite{naudio} - a well establish open source libary, still being updated, avialible throught NuGet (Visual Studio Market..)
	\item Alvas.Audio \cite{alvas} - Propieratary C\# audio library for .Net, Requires a license.
	\item BASS.NET \cite{bass} - a 3rd party .Net wrapper for the BASS audio library, still being updated, requires a license.
	\item SoundPlayer - intergrated in .Net framework, only supports .wav PCM data stream.
\end{itemize}

	The features of these candidates is pretty distributed, apart from SoundPlayer class of the .Net framework, Should the system be required to handle other compressed data streams, SoundPlayer candicate would strugle due to having to convert the data first delivering it. Of the remaining candidates the project group sought to minimize cost of the system, and maintain a open source system as much as possible, there by leaving out the propieratary candidates. Leaving Naudio as the only candidate and most sensible in terms of extendibilty.